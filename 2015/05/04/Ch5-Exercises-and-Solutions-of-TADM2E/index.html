<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>算法设计手册第二版第五章课后习题解答 | 屌丝程序员的自留地</title>
  <meta name="author" content="James Shi">
  
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="算法设计手册第二版第五章课后习题解答"/>
  <meta property="og:site_name" content="屌丝程序员的自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="屌丝程序员的自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">屌丝程序员的自留地</a></h1>
  <h2><a href="/">码农在此种地</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">文章列表</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-03T16:00:00.000Z"><a href="/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/">2015-05-04</a></time>
      
      
  
    <h1 class="title">算法设计手册第二版第五章课后习题解答</h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我的解答"><span class="toc-number">2.</span> <span class="toc-text">我的解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">2.1.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6"><span class="toc-number">2.1.1.</span> <span class="toc-text">5-6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7"><span class="toc-number">2.1.2.</span> <span class="toc-text">5-7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8"><span class="toc-number">2.1.3.</span> <span class="toc-text">5-8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9"><span class="toc-number">2.1.4.</span> <span class="toc-text">5-9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10"><span class="toc-number">2.1.5.</span> <span class="toc-text">5-10</span></a></li></ol></li></ol></li></ol>
          </div>
        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E</a></p>
<h2 id="我的解答">我的解答</h2><h3 id="遍历">遍历</h3><h4 id="5-6">5-6</h4><p>题目</p>
<p>In breadth-first and depth-first search, an undiscovered node is marked discovered when it is first encountered, and marked processed when it has been completely searched. At any given moment, several nodes might be simultaneously in the discovered state.<br>(a) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a breadth-first search starting from v.<br>(b) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a depth-first search starting from v.<br>(c) Describe a graph on n vertices and a particular starting vertex v such that at some point Θ(n) nodes remain undiscovered, while Θ(n) nodes have been processed during a depth-first search starting from v. (Note, there may also be discovered nodes.)</p>
<p>解答</p>
<p>(a) Wrost case: 所有的节点都与根节点v直接相连。<br>(b) Wrost case: 所有的节点的出度都小于等于2，即所有的点都在一条线上。<br>(c) 非连通图。</p>
<h4 id="5-7">5-7</h4><p>题目</p>
<p>Given pre-order and in-order traversals of a binary tree, is it possible to reconstruct the tree? If so, sketch an algorithm to do it. If not, give a counterexample. Repeat the problem if you are given the pre-order and post-order traversals.</p>
<p>解答</p>
<p>(a) pre-order and in-order</p>
<p>先序遍历特点：第一个节点是根节点。<br>中序遍历特点：先遍历根节点的左子树，再根节点，然后根节点的右子树。</p>
<p>算法思路：</p>
<ol>
<li>根据先序遍历序列得到root。</li>
<li>根据root和中序遍历序列得到左右子树。</li>
<li>递归建立左子树。</li>
<li>递归建立右子树。</li>
</ol>
<p>(b) pre-order and post-order</p>
<p>后序遍历特点：先遍历根节点的左子树，再根节点的右子树，然后根节点。</p>
<p>只有先、后遍历序列，无法划分左右子树，无法建立树。</p>
<h4 id="5-8">5-8</h4><p>题目</p>
<p>Present correct and efficient algorithms to convert an undirected graph G between the following graph data structures. You must give the time complexity of each algorithm, assuming n vertices and m edges.<br>(a) Convert from an adjacency matrix to adjacency lists.<br>(b) Convert from an adjacency list to an incidence matrix. An incidence matrix M has a row for each vertex and a column for each edge, such that M[i,j]=1 if vertex i is part of edge j, otherwise M[i,j]=0.<br>(c) Convert from an incidence matrix to adjacency lists.</p>
<p>解答</p>
<p>访问所有的边和点的时间复杂度：<br>邻接矩阵：O(n<sup>2</sup>)<br>邻接链表：O(n+m)</p>
<p>(a) 无向图的邻接矩阵具有对称性，不必遍历整个矩阵。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> n</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">from</span> x+<span class="number">1</span> <span class="keyword">to</span> n</span><br><span class="line">        <span class="keyword">if</span> M[x][y] = <span class="number">1</span></span><br><span class="line">            insert(&amp;g, x, y)</span><br></pre></td></tr></table></figure>
<p>需要花费O(n<sup>2</sup>)从邻接矩阵读数据，然后花费O(n+m)建立邻接链表。</p>
<p>(b) 关联矩阵：形成点和边的映射，矩阵大小为 <code>n·m</code>，建立关联矩阵并初始化需要O(nm)。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">edgesx[]    <span class="comment">// 边i连接的x节点</span></span><br><span class="line">edgesy[]    <span class="comment">// 边i连接的y节点，x&lt;y</span></span><br><span class="line">cur = -<span class="number">1</span>    <span class="comment">// 当前边的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">list_2_incidence</span><span class="params">(&amp;g, IM[][])</span></span>:</span><br><span class="line">    <span class="keyword">for</span> x from <span class="number">1</span> to g-&gt;nvertices</span><br><span class="line">        <span class="tag">p</span> = p-&gt;edges[x]</span><br><span class="line">        while <span class="tag">p</span> != null</span><br><span class="line">            y = p-&gt;y</span><br><span class="line">            <span class="keyword">if</span> !<span class="function"><span class="title">recorded_edge</span><span class="params">(x, y)</span></span></span><br><span class="line">                <span class="function"><span class="title">recording_edge</span><span class="params">(x,y)</span></span></span><br><span class="line">                IM[x][cur] = <span class="number">1</span></span><br><span class="line">                IM[y][cur] = <span class="number">1</span></span><br><span class="line">            <span class="tag">p</span> = p-&gt;next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recording_edge</span><span class="params">(x, y)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="function"><span class="title">swap</span><span class="params">(x, y)</span></span></span><br><span class="line">    edgesx[i] = x</span><br><span class="line">    edgesy[i] = y</span><br><span class="line">    cur++</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recorded_edge</span><span class="params">(x, y)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="function"><span class="title">swap</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">for</span> <span class="tag">i</span> from <span class="number">0</span> to cur</span><br><span class="line">        <span class="keyword">if</span> x == edges[i] &amp;&amp; y == edgesy[i] <span class="comment">// 存在一个i</span></span><br><span class="line">            return <span class="number">1</span></span><br><span class="line">    return <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在关联矩阵中为每条边写入数据需要花费O(1)，共m条边，需要花费O(m)。从邻接链表读取数据，并检测该边是不是已经记录需要花费O(n+m<sup>2</sup>)，其中检测一条边需要O(m)。因此总的时间花费为O(nm+n+m*m) = O(nm+m<sup>2</sup>)。</p>
<p>(c) 遍历每一条边，然后插入到邻接矩阵</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j from <span class="number">1</span> to m</span><br><span class="line">    x = y = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="tag">i</span> from <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">if</span> M[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> x == -<span class="number">1</span>, x = <span class="tag">i</span></span><br><span class="line">            <span class="keyword">else</span> y = <span class="tag">i</span>, <span class="function"><span class="title">insert</span><span class="params">(&amp;g, x, y)</span></span>, break</span><br></pre></td></tr></table></figure>
<p>遍历需要O(nm)，插入需要O(1)，故共需要O(nm)。</p>
<h4 id="5-9">5-9</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a tree. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the tree in Figure 5.17(a).<br>Give an O(n) algorithm for evaluating such an expression, where there are n nodes in the tree.</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/444.JPG" alt="Figure 5.17"></p>
<p>解答</p>
<p>采用递归的方式，获得左子树操作数和右子树操作数，然后做运算，每个节点都会访问一次，时间复杂度O(n)。</p>
<p>假设树节点的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> calc(op1, root-&gt;<span class="keyword">operator</span>, op2)  <span class="comment">// 进行基本运算</span></span><br></pre></td></tr></table></figure>
<h4 id="5-10">5-10</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a DAG (directed acyclic graph) with common subexpressions removed. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the DAG in Figure (see book)(b). Give an O(n+m) algorithm for evaluating such a DAG, where there are n nodes and m edges in the DAG. Hint: modify an algorithm for the tree case to achieve the desired efficiency.</p>
<p>解答</p>
<p>为节点设置一个标记，若已算过该子树，标记设置为true。当再次访问此子树时，可直接获得该子树的结果。再次访问的次数不会超过m，时间复杂度为O(n+m)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;           <span class="comment">// 该子树的值是否已计算</span></span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;left and root-&gt;right and flag = <span class="keyword">true</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        root-&gt;val = calc(op1, root-&gt;<span class="keyword">operator</span>, op2) <span class="comment">// 进行基本运算</span></span><br><span class="line">        root-&gt;flag = <span class="keyword">true</span></span><br><span class="line">        <span class="keyword">return</span>   root-&gt;val</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/TADM/">TADM</a>, <a href="/tags/图论/">图论</a>, <a href="/tags/搜索/">搜索</a>, <a href="/tags/面试/">面试</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/" data-title="算法设计手册第二版第五章课后习题解答" data-url="http://yoursite.com/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stb"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/教程/">教程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Github-Pages/">Github Pages</a><small>1</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>2</small></li>
  
    <li><a href="/tags/TADM/">TADM</a><small>2</small></li>
  
    <li><a href="/tags/图论/">图论</a><small>1</small></li>
  
    <li><a href="/tags/待办/">待办</a><small>1</small></li>
  
    <li><a href="/tags/排序/">排序</a><small>1</small></li>
  
    <li><a href="/tags/搜索/">搜索</a><small>2</small></li>
  
    <li><a href="/tags/面试/">面试</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 James Shi
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>