<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>算法设计手册第二版第五章课后习题解答 | James&#39;s Blog</title>
  <meta name="author" content="James Shi">
  
  <meta name="description" content="屌丝程序员的自留地#为搜索引擎留的">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="算法设计手册第二版第五章课后习题解答"/>
  <meta property="og:site_name" content="James&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="James&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">James&#39;s Blog</a></h1>
  <h2><a href="/">码农 登山 骑行 摄影</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/archives">文章列表</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-05-03T16:00:00.000Z"><a href="/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/">2015-05-04</a></time>
      
      
  
    <h1 class="title">算法设计手册第二版第五章课后习题解答</h1>
  

    </header>
    <div class="entry">
      
        
          <div id="toc" class="toc-article">
          <strong class="toc-title">文章目录</strong>
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目Wiki及参考答案"><span class="toc-number">1.</span> <span class="toc-text">题目Wiki及参考答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我的解答"><span class="toc-number">2.</span> <span class="toc-text">我的解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">2.1.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6"><span class="toc-number">2.1.1.</span> <span class="toc-text">5-6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7"><span class="toc-number">2.1.2.</span> <span class="toc-text">5-7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8"><span class="toc-number">2.1.3.</span> <span class="toc-text">5-8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9"><span class="toc-number">2.1.4.</span> <span class="toc-text">5-9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10"><span class="toc-number">2.1.5.</span> <span class="toc-text">5-10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12"><span class="toc-number">2.1.6.</span> <span class="toc-text">5-12</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-13"><span class="toc-number">2.1.7.</span> <span class="toc-text">5-13</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-14"><span class="toc-number">2.1.8.</span> <span class="toc-text">5-14</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-15"><span class="toc-number">2.1.9.</span> <span class="toc-text">5-15</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-16"><span class="toc-number">2.1.10.</span> <span class="toc-text">5-16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-17"><span class="toc-number">2.1.11.</span> <span class="toc-text">5-17</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-18"><span class="toc-number">2.1.12.</span> <span class="toc-text">5-18</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-19"><span class="toc-number">2.1.13.</span> <span class="toc-text">5-19</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-20"><span class="toc-number">2.1.14.</span> <span class="toc-text">5-20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-21"><span class="toc-number">2.1.15.</span> <span class="toc-text">5-21</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-22"><span class="toc-number">2.1.16.</span> <span class="toc-text">5-22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-23"><span class="toc-number">2.1.17.</span> <span class="toc-text">5-23</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-25_未解决"><span class="toc-number">2.1.18.</span> <span class="toc-text">5-25 未解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-26_mother_vertex"><span class="toc-number">2.1.19.</span> <span class="toc-text">5-26 mother vertex</span></a></li></ol></li></ol></li></ol>
          </div>
        
        <blockquote>
<p>列出的解答仅为自己的思路，仅供参考，欢迎指出错误。</p>
</blockquote>
<h2 id="题目Wiki及参考答案">题目Wiki及参考答案</h2><p><a href="http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E" target="_blank" rel="external">http://www.algorithm.cs.sunysb.edu/algowiki/index.php/Graphs-TADM2E</a></p>
<h2 id="我的解答">我的解答</h2><h3 id="遍历">遍历</h3><h4 id="5-6">5-6</h4><p>题目</p>
<p>In breadth-first and depth-first search, an undiscovered node is marked discovered when it is first encountered, and marked processed when it has been completely searched. At any given moment, several nodes might be simultaneously in the discovered state.<br>(a) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a breadth-first search starting from v.<br>(b) Describe a graph on n vertices and a particular starting vertex v such that Θ(n) nodes are simultaneously in the discovered state during a depth-first search starting from v.<br>(c) Describe a graph on n vertices and a particular starting vertex v such that at some point Θ(n) nodes remain undiscovered, while Θ(n) nodes have been processed during a depth-first search starting from v. (Note, there may also be discovered nodes.)</p>
<a id="more"></a>
<p>解答</p>
<p>(a) Wrost case: 所有的顶点都与根顶点v直接相连。<br>(b) Wrost case: 所有的顶点的出度都小于等于2，即所有的点都在一条线上。<br>(c) 非连通图。</p>
<h4 id="5-7">5-7</h4><p>题目</p>
<p>Given pre-order and in-order traversals of a binary tree, is it possible to reconstruct the tree? If so, sketch an algorithm to do it. If not, give a counterexample. Repeat the problem if you are given the pre-order and post-order traversals.</p>
<p>解答</p>
<p>(a) pre-order and in-order</p>
<p>先序遍历特点：第一个顶点是根顶点。<br>中序遍历特点：先遍历根顶点的左子树，再根顶点，然后根顶点的右子树。</p>
<p>算法思路：</p>
<ol>
<li>根据先序遍历序列得到root。</li>
<li>根据root和中序遍历序列得到左右子树。</li>
<li>递归建立左子树。</li>
<li>递归建立右子树。</li>
</ol>
<p>(b) pre-order and post-order</p>
<p>后序遍历特点：先遍历根顶点的左子树，再根顶点的右子树，然后根顶点。</p>
<p>只有先、后遍历序列，无法划分左右子树，无法建立树。</p>
<h4 id="5-8">5-8</h4><p>题目</p>
<p>Present correct and efficient algorithms to convert an undirected graph G between the following graph data structures. You must give the time complexity of each algorithm, assuming n vertices and m edges.<br>(a) Convert from an adjacency matrix to adjacency lists.<br>(b) Convert from an adjacency list to an incidence matrix. An incidence matrix M has a row for each vertex and a column for each edge, such that M[i,j]=1 if vertex i is part of edge j, otherwise M[i,j]=0.<br>(c) Convert from an incidence matrix to adjacency lists.</p>
<p>解答</p>
<p>访问所有的边和点的时间复杂度：<br>邻接矩阵：O(n<sup>2</sup>)<br>邻接链表：O(n+m)</p>
<p>(a) 无向图的邻接矩阵具有对称性，不必遍历整个矩阵。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">from</span> <span class="number">1</span> <span class="keyword">to</span> n</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">from</span> x+<span class="number">1</span> <span class="keyword">to</span> n</span><br><span class="line">        <span class="keyword">if</span> M[x][y] = <span class="number">1</span></span><br><span class="line">            insert(&amp;g, x, y)</span><br></pre></td></tr></table></figure>
<p>需要花费O(n<sup>2</sup>)从邻接矩阵读数据，然后花费O(n+m)建立邻接链表。</p>
<p>(b) 关联矩阵：形成点和边的映射，矩阵大小为 <code>n·m</code>，建立关联矩阵并初始化需要O(nm)。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">edgesx[]    <span class="comment">// 边i连接的x顶点</span></span><br><span class="line">edgesy[]    <span class="comment">// 边i连接的y顶点，x&lt;y</span></span><br><span class="line">cur = -<span class="number">1</span>    <span class="comment">// 当前边的编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">list_2_incidence</span><span class="params">(&amp;g, IM[][])</span></span>:</span><br><span class="line">    <span class="keyword">for</span> x from <span class="number">1</span> to g-&gt;nvertices</span><br><span class="line">        <span class="tag">p</span> = p-&gt;edges[x]</span><br><span class="line">        while <span class="tag">p</span> != null</span><br><span class="line">            y = p-&gt;y</span><br><span class="line">            <span class="keyword">if</span> !<span class="function"><span class="title">recorded_edge</span><span class="params">(x, y)</span></span></span><br><span class="line">                <span class="function"><span class="title">recording_edge</span><span class="params">(x,y)</span></span></span><br><span class="line">                IM[x][cur] = <span class="number">1</span></span><br><span class="line">                IM[y][cur] = <span class="number">1</span></span><br><span class="line">            <span class="tag">p</span> = p-&gt;next</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recording_edge</span><span class="params">(x, y)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="function"><span class="title">swap</span><span class="params">(x, y)</span></span></span><br><span class="line">    edgesx[i] = x</span><br><span class="line">    edgesy[i] = y</span><br><span class="line">    cur++</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recorded_edge</span><span class="params">(x, y)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> (x &gt; y)</span><br><span class="line">        <span class="function"><span class="title">swap</span><span class="params">(x, y)</span></span></span><br><span class="line">    <span class="keyword">for</span> <span class="tag">i</span> from <span class="number">0</span> to cur</span><br><span class="line">        <span class="keyword">if</span> x == edges[i] &amp;&amp; y == edgesy[i] <span class="comment">// 存在一个i</span></span><br><span class="line">            return <span class="number">1</span></span><br><span class="line">    return <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在关联矩阵中为每条边写入数据需要花费O(1)，共m条边，需要花费O(m)。从邻接链表读取数据，并检测该边是不是已经记录需要花费O(n+m<sup>2</sup>)，其中检测一条边需要O(m)。因此总的时间花费为O(nm+n+m*m) = O(nm+m<sup>2</sup>)。</p>
<p>(c) 遍历每一条边，然后插入到邻接矩阵</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j from <span class="number">1</span> to m</span><br><span class="line">    x = y = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="tag">i</span> from <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">if</span> M[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> x == -<span class="number">1</span>, x = <span class="tag">i</span></span><br><span class="line">            <span class="keyword">else</span> y = <span class="tag">i</span>, <span class="function"><span class="title">insert</span><span class="params">(&amp;g, x, y)</span></span>, break</span><br></pre></td></tr></table></figure>
<p>遍历需要O(nm)，插入需要O(1)，故共需要O(nm)。</p>
<h4 id="5-9">5-9</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a tree. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the tree in Figure 5.17(a).<br>Give an O(n) algorithm for evaluating such an expression, where there are n nodes in the tree.</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Figure 5.17.JPG" alt="Figure 5.17"></p>
<p>解答</p>
<p>采用递归的方式，获得左子树操作数和右子树操作数，然后做运算，每个顶点都会访问一次，时间复杂度O(n)。</p>
<p>假设树顶点的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        <span class="keyword">return</span> calc(op1, root-&gt;<span class="keyword">operator</span>, op2)  <span class="comment">// 进行基本运算</span></span><br></pre></td></tr></table></figure>
<h4 id="5-10">5-10</h4><p>题目</p>
<p>Suppose an arithmetic expression is given as a DAG (directed acyclic graph) with common subexpressions removed. Each leaf is an integer and each internal node is one of the standard arithmetical operations <code>(+,−,*,/)</code>. For example, the expression <code>2+3*4+(3*4)/5</code> is represented by the DAG in Figure (see book)(b). Give an O(n+m) algorithm for evaluating such a DAG, where there are n nodes and m edges in the DAG. Hint: modify an algorithm for the tree case to achieve the desired efficiency.</p>
<p>解答</p>
<p>为顶点设置一个标记，若已算过该子树，标记设置为true。当再次访问此子树时，可直接获得该子树的结果。再次访问的次数不会超过m，时间复杂度为O(n+m)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> node&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">operator</span>;</span><br><span class="line">    <span class="keyword">int</span> flag;           <span class="comment">// 该子树的值是否已计算</span></span><br><span class="line">    <span class="keyword">struct</span> node *left;</span><br><span class="line">    <span class="keyword">struct</span> node *right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">calc_tree(root):</span><br><span class="line">    <span class="keyword">if</span> root-&gt;left = null and root-&gt;right = null</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> root-&gt;left and root-&gt;right and flag = <span class="keyword">true</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        op1 = calc_tree(root-&gt;left)</span><br><span class="line">        op2 = calc_tree(root-&gt;right)</span><br><span class="line">        root-&gt;val = calc(op1, root-&gt;<span class="keyword">operator</span>, op2) <span class="comment">// 进行基本运算</span></span><br><span class="line">        root-&gt;flag = <span class="keyword">true</span></span><br><span class="line">        <span class="keyword">return</span>   root-&gt;val</span><br></pre></td></tr></table></figure>
<h4 id="5-12">5-12</h4><p>题目</p>
<p>The square of a directed graph G=(V,E) is the graph G2=(V,E2) such that (u,w)∈E2 iff there exists v∈V such that (u,v)∈E and (v,w)∈E; i.e., there is a path of exactly two edges from u to w. square of a graph Give efficient algorithms for both adjacency lists and matrices.</p>
<p>解答</p>
<p>首先，必须清楚这是有向图。</p>
<ol>
<li><p>邻接矩阵</p>
<p> 这个题目的重点是找到顶点v的孙子顶点w，连接v与w。如果采用暴力的方法三层for循环遍历邻接矩阵，时间复杂度是O(n<sup>3</sup>)，代价还是很大的，尤其是n比较大，且图G是稀疏图。</p>
<p> 如果能有效降低for循环内的次数，虽然时间复杂度是O(n<sup>3</sup>)，但是实际上可能也不会那么高了。</p>
<p> 优化方案是为每个顶点建立一个队列，那么所有队列的总长度为m（图G边的总数）。这样，遍历该顶点的队列就可以得到该顶点的孩子。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j from <span class="number">1</span> to n</span><br><span class="line">        <span class="keyword">if</span> G[i,j] = <span class="number">1</span>, append(q[i], j)  <span class="comment">// 将j添加到i的队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    foreach j in q[i]</span><br><span class="line">        foreach k in q[j]</span><br><span class="line">            square_G[i,k] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p> 构建队列的时间复杂度为O(n<sup>2</sup>)，构建G<sup>2</sup>的外面两层循环时间复杂度为O(m)。则每个队列的平均长度为 m/n，则内层循环的时间复杂度为O(m/n)，总为O(m<sup>2</sup>/n)。从另外一个角度讲，G<sup>2</sup>的边数小于2m（你可以试着证明一下，我还不能给出准确的证明），那么<code>square_G[i,k] = 1</code>的执行次数小于2m。时间复杂度应该为O(n<sup>2</sup>+m)。</p>
</li>
<li><p>邻接链表</p>
<p> 现在回想一下，在邻接矩阵的解决方案中，使用的队列，就相当于邻接链表。那我们就省去了构建队列的时间，时间复杂度O(m)。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i from <span class="number">1</span> to n</span><br><span class="line">    foreach j in g-&gt;edges[i]</span><br><span class="line">        foreach k in g-&gt;edges[j]</span><br><span class="line">            insert_edges(square_g-&gt;edges, i, k, TRUE)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="5-13">5-13</h4><p>题目</p>
<p>A vertex cover of a graph G=(V,E) is a subset of vertices V′ such that each edge in E is incident on at least one vertex of V′.<br>(a) Give an efficient algorithm to find a minimum-size vertex cover if G is a tree.<br>(b) Let G=(V,E) be a tree such that the weight of each vertex is equal to the degree of that vertex. Give an efficient algorithm to find a minimum-weight vertex cover of G.<br>(c) Let G=(V,E) be a tree with arbitrary weights associated with the vertices. Give an efficient algorithm to find a minimum-weight vertex cover of G.</p>
<p>解答</p>
<ul>
<li><p>(a) 解决思路如下：</p>
<ol>
<li>叶顶点l是不能要的，因为一个叶顶点才连一条边，性价比太低了。</li>
<li>那就需要叶顶点的父顶点p。</li>
<li>p的父顶点也就不需要了。</li>
<li><p>删除p子树，就会得到一颗新的树。重复操作，直到得到空树或只有一个顶点的树。</p>
<p>怎么证明，该算法得到的就是最小的集合？<br>因为我们每次移去的子树，都尽量以一个中心顶点，带走尽量多的边，那么最后得到的顶点的集合，必然是最小的。</p>
<p>插图如下(以2叉树做例子)：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-13b.jpg" alt="顶点覆盖1"><br><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-13a.jpg" alt="顶点覆盖2"></p>
</li>
</ol>
</li>
<li><p>(b) 任何一条边在V’中至少有一个顶点，那么V’中所有顶点的度的和sum至少为m（图G的边的总数）减少V’中相邻顶点的数量，就能降低sum的值。使用(a)中的方法，可以尽量降低sum的值，因为在(a)中选择的点尽量是隔代选择。另外的隔代选择方案是吧叶顶点以及他们的父亲的父亲作为目标顶点，得到的V’同样是尽量小的。</p>
</li>
<li><p>(c) 待定<br>  要把树作为有向图处理吗？虽然我们把树表示成带箭头的，但是树是无向图，<a href="http://en.wikipedia.org/wiki/Tree_%28graph_theory%29" target="_blank" rel="external">维基百科</a>。</p>
</li>
</ul>
<h4 id="5-14">5-14</h4><p>题目</p>
<p>A <em>vertex cover</em> of a graph G=(V,E) is a subset of vertices V′∈V such that every edge in E contains at least one vertex from V′. Delete all the leaves from any depth-first search tree of G. Must the remaining vertices form a vertex cover of G? Give a proof or a counterexample.</p>
<p>解答</p>
<p>否定。反例：<br>下图得到的DFS序列可以是[1, 3, 2]，叶顶点为2,3。那么V’={1}。并不是一个顶点覆盖。</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-14.JPG" alt="5-14反例"></p>
<h4 id="5-15">5-15</h4><p>题目</p>
<p>A vertex cover of a graph G=(V,E) is a subset of vertices V′∈V such that every edge in E contains at least one vertex from V′. An independent set of graph G=(V,E) is a subset of vertices V′∈V such that no edge in E contains both vertices from V′.<br>An <em>independent vertex cover</em> is a subset of vertices that is both an independent set and a vertex cover of G. Give an efficient algorithm for testing whether G contains an independent vertex cover. What classical graph problem does this reduce to?</p>
<p>解答</p>
<p>着色问题。愣是没有想到。</p>
<h4 id="5-16">5-16</h4><p>题目</p>
<p>An <em>independent set</em> of an undirected graph G=(V,E) is a set of vertices U such that no edge in E is incident on two vertices of U.</p>
<p>(a) Give an efficient algorithm to find a maximum-size independent set if G is a tree.<br>(b) Let G=(V,E) be a tree with weights associated with the vertices such that the weight of each vertex is equal to the degree of that vertex. Give an efficient algorithm to find a maximum independent set of G.<br>(c) Let G=(V,E) be a tree with arbitrary weights associated with the vertices. Give an efficient algorithm to find a maximum independent set of G.</p>
<p>解答</p>
<ul>
<li><p>(a) 基于5-15给出的答案。我们可以先把图着色，然后遍历得到不同颜色的序列，去较短的序列作为最小的独立集合。若不能着色，则不存在最小独立集合。</p>
</li>
<li><p>(b) 有以下几点需要注意：</p>
</li>
</ul>
<ol>
<li>树肯定是可以着色的。</li>
<li>着色方案是固定的：孩子与父亲是相反的颜色。</li>
<li>题目要求找到最大的独立集合。</li>
</ol>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-16-b.JPG" alt="二叉树着色"></p>
<p>先着色，进行一次遍历，将不同颜色的放入两个序列，取总度的和较大者。</p>
<p>不进行着色的处理方案:设置root颜色为0，则其子为1。递归遍历左右子树，时间复杂度为O(n)。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">classify</span><span class="params">(root, color)</span></span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="attribute">color</span> = <span class="number">0</span> then</span><br><span class="line">        put root into list1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        put root into list2</span><br><span class="line">    <span class="keyword">if</span> root-&gt;<span class="attribute">left</span> then</span><br><span class="line">        <span class="function"><span class="title">classify</span><span class="params">(root-&gt;left, !color)</span></span></span><br><span class="line">    <span class="keyword">if</span> root-&gt;<span class="attribute">right</span> then</span><br><span class="line">        <span class="function"><span class="title">classify</span><span class="params">(root-&gt;right, !color)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>(c) 与(b)的不同仅仅是最后，取权重的和的较大者。</li>
</ul>
<h4 id="5-17">5-17</h4><p>题目</p>
<p>Consider the problem of determining whether a given undirected graph G=(V,E) contains a triangle or cycle of length 3.</p>
<p>(a) Give an O(|V|<sup>3</sup>) to find a triangle if one exists.<br>Improve your algorithm to run in time O(|V|·|E|). You may assume |V|≤|E|.<br>(b) Observe that these bounds gives you time to convert between the adjacency matrix and adjacency list representations of G.</p>
<p>解答</p>
<ul>
<li><p>(a) Brute force。</p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> inode <span class="operator">in</span> V <span class="built_in">do</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> jnode <span class="operator">in</span> Adj[inode] <span class="built_in">do</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">each</span> knode <span class="operator">in</span> Adj[jnode] <span class="built_in">do</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">each</span> lnode <span class="operator">in</span> Adj[knode] <span class="built_in">do</span></span><br><span class="line">                <span class="keyword">if</span> lnode = inode <span class="keyword">then</span></span><br><span class="line">                    <span class="constant">return</span> <span class="constant">true</span></span><br></pre></td></tr></table></figure>
<p>  时间复杂度是O(n<sup>4</sup>)，看样子不符合题目的要求。</p>
</li>
<li><p>(b) DFS。</p>
<p>  DFS可以发现图中的环，那么当检测到环时，可以进进一步检测环的大小是否为3.采用的就是DFS一次遍历，因此时间复杂度是O(|V|+|E|)。</p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process_edge(v, y):</span><br><span class="line">    <span class="keyword">if</span> parent[parent[x]] = y <span class="keyword">then</span></span><br><span class="line">        <span class="variable">is_triangle =</span> <span class="constant">true</span></span><br><span class="line">        <span class="variable">finish =</span> <span class="constant">true</span></span><br></pre></td></tr></table></figure>
<p>  <img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-17.JPG" alt="5-17"></p>
<p>  github仓库源码及测试数据:<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/5.11/5-17.c" target="_blank" rel="external">传送门—&gt;</a></p>
</li>
</ul>
<h4 id="5-18">5-18</h4><p>题目</p>
<p>Consider a set of movies M1, M2, … , Mk. There is a set of customers, each one of which indicates the two movies they would like to see this weekend. Movies are shown on Saturday evening and Sunday evening. Multiple movies may be screened at the same time. You must decide which movies should be televised on Saturday and which on Sunday, so that every customer gets to see the two movies they desire. Is there a schedule where each movie is shown at most once? Design an efficient algorithm to find such a schedule if one exists.</p>
<p>解答</p>
<p>问题原型：着色问题。把相邻的顶点安排在不同的时间。</p>
<p>最好的情况是符合着色问题，那么每个电影只需要放一遍。因此我们可以使用着色问题的算法解决这个问题，当着色失败时，则不存在这样最优的调度算法。</p>
<p><strong>思考</strong>：与着色问题不同的是电影可以放两次，怎样才能让总播放的次数达到最小呢？</p>
<p>电影可以放两次就相当于让一个点拥有两个颜色，在着色的过程中如果出现冲突，将此点标记为<code>double-color</code>，与他相连的还未着色的点可以是任意的颜色，那么如何才能保证全局最小呢？</p>
<h4 id="5-19">5-19</h4><p>题目</p>
<p>The <em>diameter</em> of a tree T=(V,E) is given by max u,v∈Vδ(u,v) (where δ(u,v) is the number of edges on the path from u to v). Describe an efficient algorithm to compute the diameter of a tree, and show the correctness and analyze the running time of your algorithm.</p>
<p>解答</p>
<p>最长路径。</p>
<p>称diameter最顶层的顶点定义了diameter。那么对任意顶点都存在两种情况：</p>
<ol>
<li>该顶点定义了diameter。</li>
<li>该顶点的任一子顶点定义了diameter。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">diameter</span><span class="params">(tree)</span></span>:</span><br><span class="line">    maxdiameter = <span class="number">0</span></span><br><span class="line">    maxdepth = secdepth = -<span class="number">1</span></span><br><span class="line">    foreach child <span class="keyword">in</span> <span class="function"><span class="title">children</span><span class="params">(tree)</span></span> do</span><br><span class="line">        depth, diameter = <span class="function"><span class="title">diameter</span><span class="params">(child)</span></span></span><br><span class="line">        <span class="keyword">if</span> diameter &gt; maxdiameter then</span><br><span class="line">            maxdiameter = diameter</span><br><span class="line">        <span class="keyword">if</span> depth &gt;= maxdepth then</span><br><span class="line">            secdepth = maxdepth</span><br><span class="line">            maxdepth = depth</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> depth &gt; secdepth then</span><br><span class="line">            secdepth = depth</span><br><span class="line">    return maxdepth, <span class="function"><span class="title">max</span><span class="params">(maxdiameter, maxdepth+secdepth+<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="5-20">5-20</h4><p>题目</p>
<p>Given an undirected graph G with n vertices and m edges, and an integer k, give an O(m+n) algorithm that finds the maximum induced subgraph H of G such that each vertex in H has degree ≥k, or prove that no such graph exists. An induced subgraph F=(U,R) of a graph G=(V,E) is a subset of U of the vertices V of G, and all edges R of G such that both vertices of each edge are in U.</p>
<p>解答</p>
<p>寻找最大的导图。特性：</p>
<ol>
<li>U中所有顶点的度&gt;=K。</li>
<li>R中所有边的顶点都在U中。</li>
</ol>
<p>假设图的存储使用的是邻接链表。</p>
<p>暴力方法：<br>一次基础遍历得到符合条件的队列O(n+m)，排序O(nlogn)。<br>再次基础遍历O(n+m)看该顶点的相邻顶点在不在队列之中O(logn)。</p>
<p>借助DFS：</p>
<p>思想：</p>
<ul>
<li>所有的边都遍历一次，然后判断是否符合要求。</li>
<li>不使用课本提供的DFS框架，使用简化的DFS。</li>
<li>发现新顶点时，递归新的顶点。</li>
<li>若该点已被发现但还未处理，处理边(v,y)，这样确保了所有的边只处理一遍。</li>
</ul>
<p>Github：<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/5.11/5-20.c" target="_blank" rel="external">传送门</a>。</p>
<h4 id="5-21">5-21</h4><p>题目</p>
<p>Let v and w be two vertices in a directed graph G=(V,E). Design a linear-time algorithm to find the number of different shortest paths (not necessarily vertex disjoint) between v and w. Note: the edges in G are unweighted.</p>
<p>解答</p>
<p>有向图的最短段路径。求数量。</p>
<p>假设v指向y1，已知y1到w的最短距离l和路径的数量c。那么从v通过y1到w的最短距离是(l+1)，数量是c。同时，v还指向了y2等其他顶点，其他的路径，有影响的只有两种情况：</p>
<ol>
<li>距离等于(l+1)，则sl = l, c=c+n。</li>
<li>距离小于(l+1)，则sl = l’, c=n’。</li>
</ol>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">no_of_shortest_path(v, w):</span><br><span class="line">    <span class="variable">is_first_child =</span> <span class="constant">true</span></span><br><span class="line">    foreach child <span class="keyword">in</span> children(v) do</span><br><span class="line">        l, <span class="variable">n =</span> no_of_shortest_path(child, w)</span><br><span class="line">        <span class="keyword">if</span> is_first_child <span class="keyword">then</span></span><br><span class="line">            <span class="variable">sl =</span> l</span><br><span class="line">            <span class="variable">c =</span> n</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> l &lt; sl <span class="keyword">then</span></span><br><span class="line">            <span class="variable">sl =</span> l</span><br><span class="line">            <span class="variable">c =</span> n</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">l =</span> sl <span class="keyword">then</span></span><br><span class="line">            <span class="variable">c =</span> c+n</span><br><span class="line">    return sl+<span class="number">1</span>, c</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong><br>答案Wiki页面给出的答案更好，因为进行了剪枝：使用BFS，记录每个顶点的level，当第一次遇到w时，记录w的level作为最小路径sl，计算有多少次遇到w时level等于sl，若某次的level小于sl，则更新sl，若level超过了sl还没有遇到w则停止进一步扩展顶点。</p>
<p>github：<a href="https://github.com/Shitaibin/The-Algorithm-Design-Manual/blob/master/5.11/5-21.c" target="_blank" rel="external">时光机</a></p>
<h4 id="5-22">5-22</h4><p>题目</p>
<p>Design a linear-time algorithm to eliminate each vertex v of degree 2 from a graph by replacing edges (u,v) and (v,w) by an edge (u,w). We also seek to eliminate multiple copies of edges by replacing them with a single edge. Note that removing multiple copies of an edge may create a new vertex of degree 2, which has to be removed, and that removing a vertex of degree 2 may create multiple edges, which also must be removed.</p>
<p>解答</p>
<p>思路是：移除所有的重复边后，进行深度遍历，度为2的点的相邻顶点必然其中之一是parent，那么进行替换。如果已经存在边(u,w)，那么只删除(u,v), (v,w)。再次从开始进行深度遍历，直到在一次遍历中没有进行替换。</p>
<p>流程示意：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-22" alt="5-22"></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">移除所有的copies</span><br><span class="line">进行深度遍历</span><br><span class="line">    如果点v度为2</span><br><span class="line">        <span class="keyword">u</span> = parent[v]</span><br><span class="line">        边(<span class="keyword">u</span>,w)不存在，插入边(<span class="keyword">u</span>,w)</span><br><span class="line">        移除(<span class="keyword">u</span>,v)，(v,w)</span><br><span class="line">        再次从开始进行深度遍历</span><br><span class="line">直到在一次遍历中没有进行替换</span><br></pre></td></tr></table></figure>
<h4 id="5-23">5-23</h4><p>题目</p>
<p>Your job is to arrange n ill-behaved children in a straight line, facing front. You are given a list of m statements of the form i hates j. If i hates j, then you do not want put i somewhere behind j, because then i is capable of throwing something at j.</p>
<p>(a) Give an algorithm that orders the line, (or says that it is not possible) in O(m+n) time.<br>(b) Suppose instead you want to arrange the children in rows such that if i hates j, then i must be in a lower numbered row than j. Give an efficient algorithm to find the minimum number of rows needed, if it is possible.</p>
<p>解答</p>
<p>(a) 这是一个拓扑排序问题。<br>i hates j: {i, j}<br>可以得到一个m条边的有向图，是否存在一条线，就等价于是否存在一个拓扑排序，可以使用DFS完成拓扑排序。</p>
<p>(b) 拓扑排序变异</p>
<p>使用BFS思想。</p>
<p>假设顶点保存了indegree和outdegree<br>row[i]是一个列表，代表了第i列的元素。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">遍历顶点，将indegree为<span class="number">0</span>的点放入列表row[<span class="number">0</span>]。</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(size(row[i]) &gt; <span class="number">0</span>):</span><br><span class="line">    <span class="keyword">foreach</span> vi <span class="keyword">in</span> row[i]:</span><br><span class="line">        <span class="function"><span class="keyword">foreach</span> vj <span class="keyword">in</span> <span class="title">child</span><span class="params">(vi)</span>:</span><br><span class="line">            delete </span>&#123;vi, vj&#125;</span><br><span class="line">            indegree[vj]--</span><br><span class="line">            <span class="keyword">if</span> indegree[vj] = <span class="number">0</span> <span class="function">then</span><br><span class="line">                <span class="title">append_to_row</span><span class="params">(i+<span class="number">1</span>, vj)</span> <span class="comment">// 把j加入到列表row[i+1]</span></span><br><span class="line">    ++i</span></span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-23.JPG" alt="5-23"></p>
<h4 id="5-25_未解决">5-25 未解决</h4><p>题目</p>
<p>An <em>arborescence</em> of a directed graph G is a rooted tree such that there is a directed path from the root to every other vertex in the graph. Give an efficient and correct algorithm to test whether G contains an arborescence, and its time complexity.</p>
<p>解答</p>
<p>首先确定G不存在子图。</p>
<p>如果存在这样一棵树，那么从root进行DFS便可以得到树。那么重点可以转移到如何找到这样一个root。一种笨的方法是对整个图进行DFS，然后遍历parent[],得到parent为[i]=-1的顶点，这些顶点都有可能是root。其中，满足以下条件的顶点必然是root，并且同时证明了存在arborescence。</p>
<ol>
<li>从该顶点开始DFS。</li>
<li>如果所有顶点都可以访问，那么该点是root。</li>
</ol>
<p><img src="http://7xixtr.com1.z0.glb.clouddn.com/Ex 5-25.JPG" alt="5-25"></p>
<h4 id="5-26_mother_vertex">5-26 mother vertex</h4><p>题目</p>
<p>A mother vertex in a directed graph G=(V,E) is a vertex v such that all other vertices G can be reached by a directed path from v.<br>(a) Give an O(n+m) algorithm to test whether a given vertex v is a mother of G, where n=|V| and m=|E|.<br>(b) Give an O(n+m) algorithm to test whether graph G contains a mother vertex.</p>
<p>解答</p>
<p>(a) 从v进行一次DFS。</p>
<p>(b) </p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/TADM/">TADM</a>, <a href="/tags/图论/">图论</a>, <a href="/tags/搜索/">搜索</a>, <a href="/tags/面试/">面试</a>
  </div>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
<!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/" data-title="算法设计手册第二版第五章课后习题解答" data-url="http://shitaibin.github.io/2015/05/04/Ch5-Exercises-and-Solutions-of-TADM2E/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"stb"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:shitaibin.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/教程/">教程</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Github-Pages/">Github Pages</a><small>1</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>3</small></li>
  
    <li><a href="/tags/TADM/">TADM</a><small>2</small></li>
  
    <li><a href="/tags/图论/">图论</a><small>1</small></li>
  
    <li><a href="/tags/待办/">待办</a><small>1</small></li>
  
    <li><a href="/tags/排序/">排序</a><small>1</small></li>
  
    <li><a href="/tags/搜索/">搜索</a><small>2</small></li>
  
    <li><a href="/tags/面试/">面试</a><small>2</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 James Shi
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>